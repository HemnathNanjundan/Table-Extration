# -*- coding: utf-8 -*-
"""co_ords_using_function____ S.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yGO463S1d6KkWbCSDJVnZBdTGl9pf0UE
"""

from pdf2image import convert_from_path
from PIL import Image
import csv
import cv2
import numpy as np
import os
import pandas as pd


def pdf_to_img(file_path,temp_dir,file_name ='Sample_',start_page=1,end_page=5 ):
     # images_from_path = []
     # with tempfile.TemporaryDirectory() as path:
   images_from_path = convert_from_path(file_path,dpi=300, output_folder=temp_dir,fmt="jpeg",output_file=file_name,paths_only=True, first_page = start_page, last_page = end_page)
         # for pg, each_image in enumerate(images_from_path):
         #     images_from_path.append(pg,each_image)
   return images_from_path

class Table:
  def __init__(self,pdf,list_num,temp_dir):
    self.pdf=pdf
    self.image=None
    self.page_num=list_num
    self.line_cords=[]
    self.table_contours=None
    self.upper=None
    self.lower=None
    self.mimg=None
    self.leftmost_vertical_line=None
    self.rightmost_vertical_line=None
    self.map={}
    self.save_path=temp_dir

    
  def Extract(self):
    images = convert_from_path(self.pdf)
    for i in range(0,len(images)):
        self.out_dir=None
        if i in self.page_num:
          # with open(self.pdf[:-4]) as f:
          #   f.write(images[i].save(self.pdf[:-4]+'_'+ 'page'+ str(i) +'.jpg', 'JPEG'))
          images[i].save(self.pdf[:-4]+'_'+ 'page'+ str(i) +'.jpg', 'JPEG')
          self.image = self.pdf[:-4]+'_'+ 'page' + str(i) +'.jpg'
          self.plot(i)
          self.Hplot(i)
          self.masking(i)
          # self.Tstructure()
          self.Tcontuors(i)
          self.center(i)
          self.grouping_rows(i)
          self.grouping_cols(i)
          self.map={}
          self.line_cords=[]
          self.table_contours=None
  

  def plot(self,page_num):
    image = cv2.imread(self.image)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (3,3), 0)
    thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]

    vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1,50))
    vertical_mask = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel, iterations=1)

    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (3, 3), 0)
    thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]

    # Detect vertical lines
    vertical_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 50))
    vertical_mask = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, vertical_kernel, iterations=1)

    # Find contours and iterate through them
    contours, _ = cv2.findContours(vertical_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    v_cords=[]
    for contour in contours:
        # Get the bounding rectangle of the contour
        x, y, w, h = cv2.boundingRect(contour)
        # Draw the start and end coordinates as circles
        cv2.circle(image, (x, y), 5, (255, 0, 0), -1)
        cv2.circle(image, (x + w, y + h), 5, (0, 0, 255), -1)
        # Display the coordinates as text
        cv2.putText(image, f"({x}, {y})", (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 0, 0), 1)
        cv2.putText(image, f"({x + w}, {y + h})", (x + w, y + h + 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 1)
        # Get the bounding rectangle of the contour
        # Append the coordinates to the list
        v_cords.append(((x, y), (x + w, y + h)))
        for i, coordinates in enumerate(v_cords):
          start = coordinates[0]
          end = coordinates[1]
          self.line_cords.append([start,end])
          # print(f"{i + 1} - {start},{end}")

    sorted_lines = sorted(v_cords, key=lambda line: line[0][0])
    self.leftmost_vertical_line = sorted_lines[0]
    self.rightmost_vertical_line = sorted_lines[-1]
    print(v_cords,"\n\n\n\n\n")
    #cv2.imshow('Plots',image)
    filename=os.path.join(self.save_path,'_page_{0}_vertical_lines.jpg'.format(page_num))
    cv2.imwrite(filename, image)
    # cv2.imwrite(os.path.join(self.out_dir,f"{self.image[:-3]}vertical_image.png"),image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

  def Tcontuors(self,page_num):
      image_with_boxes = self.mimg
      edges = cv2.Canny(self.mimg, 100, 200)  # Adjust the threshold values as needed
      self.table_contours = []
      # Minimum contour area to consider as a table
      min_area = 150 
      max_area = 2000*2000
      
    
      min_height = 10  # Minimum height of the table to avoid small artifacts
      contours, _ = cv2.findContours(image_with_boxes, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
      for contour in contours:
          x, y, w, h = cv2.boundingRect(contour)
          if max_area > cv2.contourArea(contour) > min_area  and h > min_height and (x,y,w,h) not in self.table_contours:
            self.table_contours.append((x, y, w, h))

      print(len(self.table_contours),"\n\n\n\n")
      colors = np.random.randint(0,255, size=(len(self.table_contours), 4), dtype=np.uint8)
      
      lst=[]
      for i, (x, y, w, h) in enumerate(self.table_contours):
          color = (int(colors[i][0]), int(colors[i][1]), int(colors[i][2]))
          cv2.rectangle(image_with_boxes, (x, y), (x+w, y+h), color, 3)
          top_left = (x, y)
          top_right = (x+w, y)
          bottom_right = (x+w, y+h)
          bottom_left = (x, y+h)
          # Display the coordinates
          cv2.putText(image_with_boxes, f"TL: {top_left}", (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
          # cv2.putText(image_with_boxes, f"TR: {top_right}", (x+w, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
          # cv2.putText(image_with_boxes, f"BR: {bottom_right}", (x+w, y+h+20), cv2.FONT_HERSHEY_SIMPLEX, 0.7, color, 2)
          # cv2.putText(image_with_boxes, f"BL: {bottom_left}", (x, y+h+20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
          # print(f"Table {i+1} - Edge Coordinates:")
          print("Top Left:", top_left)
          print("Top Right:", top_right)
          print("Bottom Right:", bottom_right)
          print("Bottom Left:", bottom_left)
          print()
      filename=os.path.join(self.save_path,'_page_{0}_coords.csv'.format(page_num))
      with open(filename, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['Bottom Left X', 'Bottom Left Y', 'Bottom Right X', 'Bottom Right Y', 'Top Right X', 'Top Right Y', 'Top Left X', 'Top Left Y'])
        for row in lst:
            bottom_left_x, bottom_left_y = row[0]
            bottom_right_x, bottom_right_y = row[1]
            top_right_x, top_right_y = row[2]
            top_left_x, top_left_y = row[3]
            writer.writerow([bottom_left_x, bottom_left_y, bottom_right_x, bottom_right_y, top_right_x, top_right_y, top_left_x, top_left_y])
      print(f"Coordinates saved to {filename}")
     
      filename=os.path.join(self.save_path,'_page_{0}_table_contours.jpg'.format(page_num))
      cv2.imwrite(filename, image_with_boxes)

      #cv2.imshow('Table Contours',image_with_boxes)
      cv2.waitKey(0)
      cv2.destroyAllWindows()
      # self.mimg=image_with_boxes
  def masking(self,page_num):
    image = cv2.imread(self.image)
    mask=np.zeros_like(image[:, :, 0])
    line_color = (255, 255, 255)  # White color for the lines
    line_thickness = 2

    # Draw multiple lines on the image

    for coords in self.line_cords:
        point1, point2 = coords
        cv2.line(mask, point1, point2, line_color, line_thickness)
    cv2.line(mask,self.upper[0],self.lower[0],line_color,line_thickness)
    cv2.line(mask,self.upper[1],self.lower[1],line_color,line_thickness)
    cv2.line(mask,self.leftmost_vertical_line[0],self.rightmost_vertical_line[0],line_color,line_thickness)
    cv2.line(mask,self.leftmost_vertical_line[1],self.rightmost_vertical_line[1],line_color,line_thickness)
    #cv2.imshow('Mask Image',mask)
    filename=os.path.join(self.save_path,'_page_{0}_mask.jpg'.format(page_num))
    cv2.imwrite(filename, mask)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    self.mimg=mask

  def Hplot(self,page_num):
    image = cv2.imread(self.image)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (3,3), 0)
    thresh = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)[1]
    # Detect horizontal lines
    horizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (50,1))
    horizontal_mask = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=1)
    l=[]
    # Find contours and iterate through them for horizontal lines
    contours, _ = cv2.findContours(horizontal_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    horizontal_line_coordinates = []
    for contour in contours:
        # Get the bounding rectangle of the contour
        x, y, w, h = cv2.boundingRect(contour)
        # Append the coordinates to the list
        horizontal_line_coordinates.append(((x, y),(x + w, y + h)))
    sort=sorted(horizontal_line_coordinates, key=lambda coord: coord[0][1])
    self.upper=sort[0]
    self.lower=sort[-1]
    # print(self.Hupper,self.Hlower,"\n\n\n\n")
    print(sort)
    # Display the coordinates as separate outputs
    for i, coordinates in enumerate(horizontal_line_coordinates):
        start = coordinates[0]
        end = coordinates[1]
        self.line_cords.append([start,end])
        # print(f"{i + 1} - {start},{end}")
    print(self.line_cords)
# Draw circles and display the image with coordinates
    for coordinates in horizontal_line_coordinates:
        start = coordinates[0]
        end = coordinates[1]
        cv2.circle(image, start,5,(255, 0, 0), -1)
        cv2.circle(image, end,5,(0, 255, 255), -1)
        cv2.putText(image, f" {start}", start, cv2.FONT_HERSHEY_SIMPLEX, 0.5,(255, 0, 0), 1)
        cv2.putText(image, f" {end}", (end[0] - 70, end[1] + 15), cv2.FONT_HERSHEY_SIMPLEX, 0.5,(0, 0, 255), 1)
    filename=os.path.join(self.save_path,'_page_{0}_Hor_lines_cordinates.jpg'.format(page_num))
    cv2.imwrite(filename, image)
    #cv2_imshow(image)
    # cv2.imwrite(os.path.join(self.out_dir,f"{self.image[:-3]}Horizontal_image.png"),image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

  def center(self,page_num):
    self.mid_points=[]
    image=cv2.imread(self.image)

    def find_midpoint(rectangle):
        x, y, w, h = rectangle
        midpoint_x = x + (w // 2)
        midpoint_y = y + (h // 2)
        return (midpoint_x, midpoint_y)

    # Convert the image to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    # Apply thresholding to convert the image to binary
    _, thresholded = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)
    colors = np.random.randint(0,255, size=(len(self.table_contours), 4), dtype=np.uint8)

    # Find contours in the thresholded image
    contours, _ = cv2.findContours(self.mimg, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    for contour in self.table_contours:

      x, y, w, h = contour

      # Find the midpoint of the bounding box
      midpoint = find_midpoint((x, y, w, h))
      self.map[contour]=midpoint
      # self.mid_points.append(midpoint)
      # Draw a circle at the midpoint on the image
      cv2.rectangle(image, (x, y), (x+w, y+h),(0,255,0), 3)
      cv2.circle(image, midpoint, 5, (0, 0, 255), -1)

    print(self.map,"\n\n\n\n\n")
    # Display the image with contours
    #cv2.imshow('Center Image',image)
    filename=os.path.join(self.save_path,'_page_{0}_all_lines.jpg'.format(page_num))
    cv2.imwrite(filename, image)
    # cv2.imwrite(os.path.join(self.out_dir,f"{self.image[:-3]}final_image.png"),image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    
    
  


  def grouping_rows(self,page_num):
    print("Broooooo")

    dict_rows={}
    target_y=[]
    for contour in self.map:
      if self.map[contour][1] not in target_y:
        target_y.append(self.map[contour][1])
      if self.map[contour][1] in dict_rows:
        dict_rows[self.map[contour][1]].append(contour)
      else:
        dict_rows[self.map[contour][1]]=[contour]
    sorted_numbers = sorted(target_y)
    result=[]
    current_group = [sorted_numbers[0]]

    for i in range(1, len(sorted_numbers)):
        if abs(sorted_numbers[i] - sorted_numbers[i-1]) <= 5:
            current_group.append(sorted_numbers[i])
        else:
            result.append(current_group)
            current_group = [sorted_numbers[i]]
    result.append(current_group)
    f_contours=[]
    for k in result:
      l=[]
      for h in k:
        for g in range(len(dict_rows[h])):
          l.append(dict_rows[h][g])
      f_contours.append(l)
    colors = np.random.randint(0,255, size=(len(self.table_contours), 4), dtype=np.uint8)
    image=cv2.imread(self.image)

  
    global row_contours_data
    row_contours_data = []
    for d, f in enumerate(f_contours):
      color = (int(colors[d][0]), int(colors[d][1]), int(colors[d][2]))
      num_contours = len(f)
      print("Row", d+1, "has",num_contours,"contours:")
      print("Row", d+1, "contours:", f)
      f = sorted(f , key=lambda k: k[0])
      for i, val in enumerate(f):
        # row_number = d + 1
        x, y, w, h = val
        cv2.rectangle(image, (x, y), (x+w, y+h), color, 3)
        cv2.putText(image, "Row: " + str(d), (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, color, 2)
        row_contours_data.append([d, x, y, w, h, i])
        
    # Save row contours data to a DataFrame
    global row_contours_df
    row_contours_df = pd.DataFrame(row_contours_data, columns=['Row Number', 'X', 'Y', 'Width', 'Height', 'Row_index'])
    
    filename = os.path.join(self.save_path, 'page_{0}_row_contours.csv'.format(page_num))
    
    row_contours_df.to_csv(filename, index=False)
  


    # Return the row contours DataFrame
    return row_contours_df
      
      


        



    print("DONEEEEEEEEEEE")
    print(dict_rows)
    print(target_y)
    print(f_contours)
    print(result)
    #cv2.imshow('Rows',image)
    filename=os.path.join(self.save_path,'_page_{0}_all_lines.jpg'.format(page_num))
    cv2.imwrite(filename, image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()



  def grouping_cols(self,page_num):
    dict_rows={}
    target_y=[]
    for contour in self.map:
      if self.map[contour][0] not in target_y:
        target_y.append(self.map[contour][0])
      if self.map[contour][0] in dict_rows:
        dict_rows[self.map[contour][0]].append(contour)
      else:
        dict_rows[self.map[contour][0]]=[contour]
    sorted_numbers = sorted(target_y)
    result=[]
    current_group = [sorted_numbers[0]]

    for i in range(1, len(sorted_numbers)):
        if abs(sorted_numbers[i] - sorted_numbers[i-1]) <= 5:
            current_group.append(sorted_numbers[i])
        else:
            result.append(current_group)
            current_group = [sorted_numbers[i]]
    result.append(current_group)
    f_contours=[]
    for k in result:
      l=[]
      for h in k:
        for g in range(len(dict_rows[h])):
          l.append(dict_rows[h][g])
      f_contours.append(l)
    colors = np.random.randint(0,255, size=(len(self.table_contours), 4), dtype=np.uint8)
    image=cv2.imread(self.image)
    global column_contours_data
    column_contours_data= []
    for d, f in enumerate(f_contours):
      color = (int(colors[d][0]), int(colors[d][1]), int(colors[d][2]))
      num_contours = len(f)
      print("Column", d+1, "contours:",f)
      f = sorted(f , key=lambda k: k[1])
      print("Column", d+1, "has",num_contours,"contours:")
      for i, val in enumerate(f):
        # column_number = d + 1
        x, y, w, h = val
        print("Contour", d, ": x =", x, "y =", y, "width =", w, "height =", h,"Column_index = " , i)
        cv2.rectangle(image, (x, y), (x+w, y+h), color, 3)
        cv2.putText(image, "Column: " + str(d+1) + ", Contour: " + str(i+1), (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, color, 2)
        column_contours_data.append([d , x, y, w, h, i])
        
     # Save column contours data to a DataFrame
    column_contours_df = pd.DataFrame(column_contours_data, columns=['Column Number', 'X', 'Y', 'Width', 'Height', 'Column_index'])
    
    filename = os.path.join(self.save_path, 'page_{0}_column_contours.csv'.format(page_num))
    
    column_contours_df.to_csv(filename, index=False)
    
    merged_df = pd.merge(row_contours_df, column_contours_df, on=['X', 'Y', 'Width', 'Height'], how='inner')

        # Save the merged dataframe to a CSV file
    merged_filename = os.path.join(self.save_path, 'page_{0}_merged_contours.csv'.format(page_num))
    merged_df.to_csv(merged_filename, index=False)


    
    
    return column_contours_df


    
      
  

temp_dir="D:/table_extraction"
pdf_path ="C:/Users/hemna/Downloads/of-347_file_6.pdf"
#save_path = "D:/table_extraction"
TT=Table(pdf_path,[1,2,3,4,5],temp_dir)
TT.Extract()





